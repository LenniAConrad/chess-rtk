package chess.tag;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import chess.core.Field;
import chess.core.Piece;
import chess.core.Position;

/**
 * Produces human-readable summaries of the tactical attacks present on a board.
 *
 * <p>
 * This class inspects geometric attack vectors and returns sentences that describe both single
 * attackers and forks, matching the textual style used in {@link PieceAblationTagger}. Each output
 * string is color-aware and names the attacker plus one or more threatened targets.
 * </p>
 *
 * @since 2025
 * @author Lennart A. Conrad
 */
public final class Attack {

    /**
     * Knight move offsets used for static attack enumeration.
     */
    private static final int[][] KNIGHT_DELTAS = {
            { 1, 2 }, { 2, 1 }, { 2, -1 }, { 1, -2 },
            { -1, -2 }, { -2, -1 }, { -2, 1 }, { -1, 2 }
    };

    /**
     * King move offsets used for static attack enumeration.
     */
    private static final int[][] KING_DELTAS = {
            { 1, 0 }, { 1, 1 }, { 0, 1 }, { -1, 1 },
            { -1, 0 }, { -1, -1 }, { 0, -1 }, { 1, -1 }
    };

    /**
     * Bishop sliding directions.
     */
    private static final int[][] BISHOP_DIRECTIONS = { { 1, 1 }, { 1, -1 }, { -1, 1 }, { -1, -1 } };

    /**
     * Rook sliding directions.
     */
    private static final int[][] ROOK_DIRECTIONS = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };

    /**
     * Utility class, prevents instantiation.
     */
    private Attack() {
        // Utility class
    }

    /**
     * Returns all current piece-to-piece attack descriptions for {@code position}.
     *
     * <p>
     * Each attacker emits a sentence that lists its color, square, and piece name, followed by the
     * threatened enemy pieces. Forks that hit multiple targets are grouped into a single sentence.
     * </p>
     *
     * @param position position to inspect
     * @return immutable list of attack descriptions
     */
    public static List<String> tag(Position position) {
        Objects.requireNonNull(position, "position");

        byte[] board = position.getBoard();
        List<String> attacks = new ArrayList<>();

        for (int index = 0; index < board.length; index++) {
            byte piece = board[index];
            if (piece == Piece.EMPTY) {
                continue;
            }
            appendAttacksForPiece(board, attacks, (byte) index, piece);
        }

        return Collections.unmodifiableList(attacks);
    }

    /**
     * Appends all attacks (single-target or fork) generated by the piece on {@code attackerSquare}.
     *
     * <p>
     * Only attacks against enemy pieces are emitted. When two or more enemy targets are attacked,
     * they are grouped into a single fork sentence.
     * </p>
     *
     * @param board board array to inspect for occupancy
     * @param attacks output list to append formatted sentences to
     * @param attackerSquare square of the attacking piece
     * @param attackerPiece piece code of the attacker
     */
    private static void appendAttacksForPiece(byte[] board, List<String> attacks, byte attackerSquare, byte attackerPiece) {
        boolean attackerIsWhite = Piece.isWhite(attackerPiece);
        List<Integer> targets = enumerateAttacks(board, attackerPiece, attackerSquare);

        byte firstTargetSquare = -1;
        byte firstTargetPiece = Piece.EMPTY;
        List<AttackTarget> forkTargets = null;

        for (int i = 0; i < targets.size(); i++) {
            int targetSquare = targets.get(i);
            byte targetPiece = board[targetSquare];
            if (targetPiece != Piece.EMPTY && Piece.isWhite(targetPiece) != attackerIsWhite) {
                if (firstTargetSquare == -1) {
                    firstTargetSquare = (byte) targetSquare;
                    firstTargetPiece = targetPiece;
                } else {
                    if (forkTargets == null) {
                        forkTargets = new ArrayList<>(4);
                        forkTargets.add(new AttackTarget(firstTargetSquare, firstTargetPiece));
                    }
                    forkTargets.add(new AttackTarget((byte) targetSquare, targetPiece));
                }
            }
        }

        if (firstTargetSquare == -1) {
            return;
        }

        if (forkTargets == null) {
            attacks.add(formatAttack(attackerSquare, attackerPiece, firstTargetSquare, firstTargetPiece));
            return;
        }
        attacks.add(formatFork(attackerSquare, attackerPiece, forkTargets));
    }

    /**
     * Enumerates squares targeted by {@code piece} using hardcoded direction tables.
     *
     * <p>
     * Sliding attackers stop when they hit any occupied square, mirroring the typical static attack
     * check used elsewhere in tag extraction.
     * </p>
     *
     * @param board board array
     * @param piece attacker code
     * @param square attacker square
     * @return list of attacked squares (including those currently occupied)
     */
    private static List<Integer> enumerateAttacks(byte[] board, byte piece, byte square) {
        List<Integer> targets = new ArrayList<>();
        int file = Field.getX(square);
        int rank = Field.getY(square);
        int absPiece = Math.abs(piece);

        switch (absPiece) {
            case Piece.WHITE_PAWN: {
                int direction = Piece.isWhite(piece) ? 1 : -1;
                addIfValid(targets, file - 1, rank + direction);
                addIfValid(targets, file + 1, rank + direction);
                break;
            }
            case Piece.WHITE_KNIGHT: {
                for (int[] delta : KNIGHT_DELTAS) {
                    addIfValid(targets, file + delta[0], rank + delta[1]);
                }
                break;
            }
            case Piece.WHITE_BISHOP: {
                addSlidingTargets(targets, board, file, rank, BISHOP_DIRECTIONS);
                break;
            }
            case Piece.WHITE_ROOK: {
                addSlidingTargets(targets, board, file, rank, ROOK_DIRECTIONS);
                break;
            }
            case Piece.WHITE_QUEEN: {
                addSlidingTargets(targets, board, file, rank, BISHOP_DIRECTIONS);
                addSlidingTargets(targets, board, file, rank, ROOK_DIRECTIONS);
                break;
            }
            case Piece.WHITE_KING: {
                for (int[] delta : KING_DELTAS) {
                    addIfValid(targets, file + delta[0], rank + delta[1]);
                }
                break;
            }
            default:
                break;
        }

        return targets;
    }

    /**
     * Adds sliding attack squares along each provided direction until blocked.
     *
     * @param targets accumulator for attacked squares
     * @param board board array for occupancy checks
     * @param file source file
     * @param rank source rank
     * @param directions ray vectors for bishop/rook moves
     */
    private static void addSlidingTargets(List<Integer> targets, byte[] board, int file, int rank, int[][] directions) {
        for (int[] dir : directions) {
            int f = file + dir[0];
            int r = rank + dir[1];
            while (Field.isOnBoard(f, r)) {
                int index = Field.toIndex(f, r);
                targets.add(index);
                if (board[index] != Piece.EMPTY) {
                    break;
                }
                f += dir[0];
                r += dir[1];
            }
        }
    }

    /**
     * Adds the translated index to {@code targets} if the coordinates lie on the board.
     *
     * @param targets accumulator
     * @param file file coordinate
     * @param rank rank coordinate
     */
    private static void addIfValid(List<Integer> targets, int file, int rank) {
        if (Field.isOnBoard(file, rank)) {
            targets.add(Field.toIndex(file, rank));
        }
    }

    /**
     * Formats a human-readable attack sentence.
     *
     * @param attackerSquare source square
     * @param attackerPiece attacker piece
     * @param targetSquare target square
     * @param targetPiece target piece
     * @return formatted sentence
     */
    private static String formatAttack(byte attackerSquare, byte attackerPiece, byte targetSquare, byte targetPiece) {
        return Text.colorNameLower(attackerPiece) + " " + Text.squareNameLower(attackerSquare) + " "
                + Text.pieceNameLower(attackerPiece) + " attacks " + Text.colorNameLower(targetPiece) + " "
                + Text.squareNameLower(targetSquare) + " " + Text.pieceNameLower(targetPiece);
    }

    /**
     * Formats a fork description when an attacker has multiple opponents in range.
     *
     * @param attackerSquare source square
     * @param attackerPiece attacker piece
     * @param targets threatened opponents
     * @return formatted sentence describing the fork
     */
    private static String formatFork(byte attackerSquare, byte attackerPiece, List<AttackTarget> targets) {
        StringBuilder builder = new StringBuilder();
        builder.append(Text.colorNameLower(attackerPiece)).append(" ").append(Text.squareNameLower(attackerSquare)).append(" ")
                .append(Text.pieceNameLower(attackerPiece)).append(" is forking ");
        for (int i = 0; i < targets.size(); i++) {
            AttackTarget target = targets.get(i);
            if (i > 0) {
                if (i == targets.size() - 1) {
                    builder.append(" and ");
                } else {
                    builder.append(", ");
                }
            }
            builder.append(Text.colorNameLower(target.piece)).append(" ").append(Text.squareNameLower(target.square)).append(" ")
                    .append(Text.pieceNameLower(target.piece));
        }
        return builder.toString();
    }

    /**
     * Represents a single threatened piece during fork formatting.
     */
    private static final class AttackTarget {

        /**
         * Square index of the threatened piece.
         */
        private final byte square;

        /**
         * Piece code of the threatened occupant.
         */
        private final byte piece;

        /**
         * Creates a fork target entry for {@link #formatFork(byte, byte, List)}.
         *
         * @param square square index of the threatened piece
         * @param piece piece code of the threatened piece
         */
        private AttackTarget(byte square, byte piece) {
            this.square = square;
            this.piece = piece;
        }
    }
}
